#include <ts_util/ts_util.hpp>

#include <boost/lexical_cast.hpp>
#include <boost/program_options.hpp>
#include <boost/foreach.hpp>

#include <iostream>
#include <cassert>
#include <cstdio>
#include <set>
#include <string>
#include <vector>

//  g++ packet_inserter.cpp -lts_util -lboost_system -lboost_program_options -lboost_filesystem


using ts_util::TransportStream;
using ts_util::TSPacket;
using ts_util::NULL_PACKET_PID;
using std::cout;
using std::endl;
using std::set;
using std::string;
using std::vector;
using boost::lexical_cast;
using boost::program_options::options_description;
using boost::program_options::value;

namespace po = boost::program_options;


void replacePackets(TransportStream &inputTS, TransportStream &outputTS, vector<TSPacket> &vts){
	while (inputTS.hasPacket()){
		TSPacket packetToWrite = inputTS.getCurrentPacket();
		inputTS.next();
		int pid = packetToWrite.getPID();

		for (int i = 0; i < vts.size(); i++){
			if (vts[i].getPID() == pid){
				packetToWrite = vts[i];
			}
		}
		outputTS.writePacketInPosition( packetToWrite );
		outputTS.next();
	}
}


void insertPacket(TransportStream &tsInput, TransportStream &tsOutput, TransportStream &packet, int interval){
	long long packetsBetweenAppearance = tsInput.calculateBitrate() * interval / 188000LL;
	bool shouldInsert = true;
	TSPacket insertionPacket = packet.getCurrentPacket();
	tsInput.goToPacket(1);
	for (int i = 1; tsInput.hasPacket(); tsInput.next(), tsOutput.next(), i++){
		if ( i % packetsBetweenAppearance == 0){
			shouldInsert = true;
		}
		TSPacket p = tsInput.getCurrentPacket();
		if (shouldInsert && p.getPID() == NULL_PACKET_PID){
			p = insertionPacket;
			shouldInsert = false;
		}
		tsOutput.writePacketInPosition(p);
	}
	//Calcular bitrate
	//Contar paquetes entre aparicion y aparicion
	//Ver en qué puntos se debe insertar los packets
	//Insertar lo más cerca que se pueda.
}

int main (int argc, char** argv)
{

	options_description desc("Allowed options");
	desc.add_options()
		("help", "produce help message")
		("sourcets,sts", value<string>()->required(), "ts file which will be modified by inserting packets into previous null packets")
		("outputts,ots", value<string>()->required(), "ts file generated by the insertion of packets")
		("packet,p", value< string >()->required(), "ts that contains the packet that will be inserted")
		("interval,i", value< int >()->required(), "maximal number of milliseconds between appearance. This program is best effort.");

	po::variables_map vm;
	po::store(po::parse_command_line(argc, argv, desc), vm);

	if (vm.count("help")){
		cout << desc << '\n';
		return 0;
	}
	po::notify(vm);

	TransportStream packet(vm["packet"].as<string>());
	if (packet.getSizeInPackets() != 1){
		cout << "There should be only one packet in " << vm["packet"].as<string>() << '\n';
		return 0;
	}

	TransportStream tsInput(vm["sourcets"].as<string>());
	TransportStream tsOutput(vm["outputts"].as<string>(), true); // EL true es para forzar la creacion del
														     // archivo.

	//replacePackets(tsInput, tsOutput, vts);
	insertPacket(tsInput, tsOutput, packet, vm["interval"].as<int>());
	return 0;
}






